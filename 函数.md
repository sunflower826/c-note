#  函数（构成程序的基本模块）

##  一.库函数

C语言中常用的库函数：

注：头文件类型不同

1.数学函数：pow（a,b）;a的b的幂次方；  sqrt(b);计算平方根；   fabs（）；计算绝对值

​                       log（a）；计算lnx的值；   log10(x);计算lgx的值；exp(x);e的x的幂次方；

​                       sin(x);cox(x)

2.IO函数：Input Output

3.字符串操作函数：strlen strcpy  strcat  strcmp  strstr  strtok   strerror  

4.内存操作函数:memcpy  memmove  memset    memcmp

5.时间/日期函数

6.其他库函数:如下链接可以查询

**例子**：strcpy  - string copy - 字符串拷贝(注:字符串的结束标志\0也会被拷贝)

​           strcpy(arr2,arr1) - 把arr1拷贝到arr2

> #include <stdio.h>
> #include <string.h>
> int main()
> {
>     char arr1[] = "bit";
>     char arr2[20] = "#########";
>     strcpy(arr2,arr1);
>     printf("%s\n",arr2);
>     return 0;
> }

​          strlen - string length - 字符串长度有关

<https://en.cppreference.com>

[cplusplus.com](https://cplusplus.com/)

##  二.自定义函数

函数定义的基本格式 

​        返回值类型   函数名(类型    形式参数1， 类型    形式参数2，.....)

​        int                  get_max(int     x                    int            y                   )

​        {

​               声明语句序列

​               可执行语句序列

​        }

> #include <stdio.h>
> //定义函数
> int get_max(int x,int y)
> {
>     if(x>y)
>         return x;
>     else
>         return y;
> }
> int main()
> {
>     int a = 10;
>     int b = 20;
>     int max = get_max(a,b);//函数的使用
>     printf("max = %d\n",max);
>     return 0;
> }

## 三. 函数的参数

**实际参数(实参)**：

> 真实传给函数的参数，叫实参。实参可以是：常量，变量，表达式，函数等。无论实参是何种类型的
>
> 量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。
>
> 如：上面的max

**形式参数(形参)：** 

> 形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存
>
> 单元），所以叫形式参数。形式参数当函数调用完之后就自动销毁了。因此形式参数只在函数中有效。
>
> 如：上面的x，y

**注：** 当实参传给形参的时候，形参其实是实参的一份临时拷贝，对形参的修改是不会改变实参的。

## 四. 函数的调用

**传值调用**

> 函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参。

**传址调用** 

> - 传址调用是把函数外部创建变量的内存地址传递给函数参数的一种调用函数的方式。
>
> - 这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是函数内部可
>
>   以直接操作函数外部的变量。

##  五.函数的嵌套调用和链式访问

函数与函数之间可以有机的结合的

**链式访问**

> 把一个函数的返回值作为另外一个函数的参数
>
> #include <stdio.h>
> #include <string.h>
> int main()
> {
>    int len = 0;
>    //1
>    //len = strlen("abc");
>    //printf("%d\n",len);
>    //2
>    printf("%d\n",strlen("abc")) ;
>    return 0;
> }

##  六.函数的声明和定义

**函数声明：**

> 1.告诉编译器有一个函数叫什么，参数是什么，返回类型是什么。但是具体是不是存在，无关紧要
>
> 2.函数的一般出现在函数的使用之前。要**先声明后使用**
>
> 3.函数的声明一般放在头文件(sth.h)中

**函数的定义：**

> 函数的定义是指函数的具体体现，交代函数的功能实现
>
> #include <stdio.h>
> //函数的声明
> int Add(int x,int y);//一般放在头文件中
> //函数的定义
> int Add(int x,int y)
> {
>     int z = x+y;
>     return z;
> }
>
> int main()
> {
>     int a = 10;
>     int b = 20;
>     int sum = Add(a,b);//函数的调用
>     //int sum = 0;
>     //sum = Add(a,b);
>     printf("%d\n",sum);
>    return 0;
> }

##  七.函数的递归

**什么是递归？**

> 程序调用自身的编程技巧称为递归。递归作为一种算法在程序设计语言中广泛应用。
>
> 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一
>
> 个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略
>
> 只需少量的程序就可以描述出解题过程所需要的多次重复计算，大大的减少了程序的
>
> 代码量。**递归的主要思考方式在于：把大事化小** 
>
> //递归方法实现计算整数n的阶乘
> #include <stdio.h>
> long Fact(int n);
>
> int main()
> {
>     int n;
>     long result;
>     printf("Input n:");
>     scanf("%d",&n);
>     result = Fact(n);//调用递归函数Fact()计算n!
>     if(result = -1)//处理非法数据
>         printf("n<0,data error!\n");
>     else
>         printf("%d! = %ld\n",n,result);
>     return 0;
> }
>
> long Fact(int n)
> {
>     if(n<0)
>         return -1;//处理非法数据
>     else if(n == 0||n == 1)//基线情况，即递归终止条件
>         return 1;
>     else
>         return(n*Fact(n-1));//递归调用，利用（n-1)!计算n！
> }

![](../picture/微信图片_20231023122653.jpg)

**递归两个必要条件**

- 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
- 每次递归调用后越来越接近这个限制条件。

注：递归常见错误:栈溢出

![](../picture/微信图片_20231023010153.jpg)

##  八.变量的作用域和生存期

**1.变量的作用域：**

> 程序中被花括号括起来的区域，叫做语句块。函数体是语句块，分支语句和循环体也是语句块。
>
> 变量作用域的规则是：每个变量仅在定义它的语句块（包含下级语句块）内有效，并且拥有自己的存储空间。
>
> 不在任何语句块内定义的变量，称为**全局变量**
>
> 在除整个程序以外的其他语句块内定义的变量，称为**局部变量**

**2.变量的生产期**

自动变量：auto 类型名 变量名；

> 自动变量在定义时不会自动初始化
>
> 自动变量在退出函数后，其分配的内存立即被释放

静态变量：static 类型名 变量名；

> static修饰局部变量，局部变量的生命周期变长
>
> static修饰全局变量，改变了变量的作用域，让静态的全局变量只能在自己的源文件内部使用，出了源文件就无法使用了
>
> static修饰函数，改变了函数的作用域，把外部链接属性变为内部链接属性

外部函数：extern 类型名 变量名；

> 外部变量也是在静态存储区内分配内存的，其生存期是整个程序的运行期。没有显式初始化的外部变量由编译程序自动
>
> 初始化为0

寄存器变量：register类型名 变量名；

